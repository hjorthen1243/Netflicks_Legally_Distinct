package DAL;

import BE.Category;
import java.io.IOException;
import java.sql.*;
import java.util.*;

import static java.sql.Statement.RETURN_GENERATED_KEYS;

public class CategoryDAO implements ICategoryDAO {
    MyDatabaseConnector databaseConnector;
    MyOMDBConnector myOMDBConnector;

    //constructor
    public CategoryDAO() throws IOException {
        databaseConnector = new MyDatabaseConnector();
        myOMDBConnector = new MyOMDBConnector();
    }

    /**
     * Return all the categories there is, even if there are no movies added to it
     *
     * @return List<Category> allCategoryList
     * @throws Exception Exception
     */
    @Override
    public List<Category> getAllCategories() throws Exception {
        List<Category> allCategoryList = new ArrayList<>();
        getCategories(allCategoryList);
        return allCategoryList; //Return the full set of categories
    }

    /**
     * Returns all Categories as an ArrayList
     *
     * @return ArrayList<Category>
     * @throws Exception
     */
    public ArrayList<Category> getAllCategoriesArray() throws Exception {
        ArrayList<Category> allCategoryList = new ArrayList<>();
        getCategories(allCategoryList);
        return allCategoryList; //Return the full set of categories
    }

    /**
     * Queries the DB for all categories
     *
     * @param categoryLists gets all categories
     * @throws Exception
     */
    public void getCategories(List<Category> categoryLists) throws Exception {
        try (Connection conn = databaseConnector.getConnection()) {
            //SQL String which gets all Categories
            String sql = "SELECT * FROM Categories;";

            ArrayList<Category> categories = (ArrayList<Category>) categoryLists;
            //Execute the SQL statement
            executeStatements(categories, sql, conn);

        } catch (Exception exception) {
            exception.printStackTrace();
            throw new Exception("Was not able to get all categories");
        }
    }

    /**
     * Creates a new category and pushes it into the DB
     *
     * @param categoryName the new name of the category
     * @return The new Category with an ID attached.
     * @throws Exception Exception
     */
    @Override
    public Category createNewCategory(String categoryName) throws Exception {
        //SQL String which adds the category to the DB
        String sql = "INSERT INTO Categories(Category) VALUES (?);";
        int id = 0; //ID is autogenerated by DB, so it is initially set to 0

        //Try with resources on the databaseConnector
        try (Connection conn = databaseConnector.getConnection()) {

            //Statement is a prepared SQL statement
            PreparedStatement ps = conn.prepareStatement(sql, RETURN_GENERATED_KEYS);

            //Bind parameters to the SQL statement
            ps.setString(1, categoryName);

            //Execute Update
            ps.executeUpdate();

            ResultSet rs = ps.getGeneratedKeys();
            //Gets the next key on the column index 1(id for categories) sets id to the new value
            if (rs.next()) {
                id = rs.getInt(1);
            }
        } catch (SQLException ex) {
            ex.printStackTrace();
            throw new Exception("Could not create category" + ex);

        }
        //Return the category, so it can be fed into the observable list
        return new Category(id, categoryName);
    }

    // Remove a category from the db
    @Override
    public void removeCategory(Category category) throws Exception {
        //Get id of the selected Category
        int id = category.getId();

        //SQL String which removes the category with the specific id from the DB
        String sql = "DELETE FROM Categories WHERE Id = " + id + ";";

        //SQL String which deletes the link between category & movie from the DB
        String sql2 = "DELETE FROM CatMovie WHERE CategoryID =" + id + ";";
        //Try with resources on the databaseConnector
        try (Connection conn = databaseConnector.getConnection()) {
            PreparedStatement ps = conn.prepareStatement(sql);
            PreparedStatement ps2 = conn.prepareStatement(sql2);
            //Execute the update
            ps2.executeUpdate();
            ps.executeUpdate();
        }
    }

    /**
     * Queries the DB for all Movies and which Categories are attached to them.
     *
     * @return Returns a Map with an Integer (the MovieID) & a List of Categories which are attached to this Integer.
     * @throws RuntimeException
     */
    @Override
    public Map<Integer, List<Category>> getCategoriesAttachedToMovies() throws RuntimeException {
        Map<Integer, List<Category>> moviesWithCategories = new HashMap<>();  //A Map used to indicate which movies (the Integer) have which categories (the list) attached.
        ArrayList<Category> categories = new ArrayList<>();
        //SQL String that gets a list of Category & Movie ID's and how they are linked and the Category Names from the DB.
        String sql = """ 
                SELECT DISTINCT MovieID, Categories.Category, Categories.id
                FROM CatMovie
                JOIN Categories ON CatMovie.categoryID = Categories.Id
                JOIN Movie ON CatMovie.MovieID = Movie.Id
                ORDER BY MovieID;""";

        try (Connection conn = databaseConnector.getConnection()) {
            Statement statement = conn.createStatement();
            ResultSet rs = statement.executeQuery(sql);
            int lastID = 0; //The initial LastID is set to 0;
            boolean firstLine = true;
            String Category; //Name of the category
            int CategoryID;  //ID of the category
            int movieID = 0; //ID of the movie
            while (rs.next()) {
                movieID = rs.getInt("MovieID"); //Map the MovieID
                if (firstLine) {
                    lastID = movieID; //Set the lastID to be the MovieID
                    firstLine = false; //From here the next line will never be the firstLine again.
                }
                if (lastID == movieID) { //If the LastID equals the movieID, then we keep mapping all categories which are connected to this movieID
                    Category = rs.getString("Category"); //Map the name of the category
                    CategoryID = rs.getInt("id"); //Map the ID of the category
                    Category c = new Category(CategoryID, Category); //Create a Category Object
                    categories.add(c); //Add the Category Object to the List
                } else {
                    moviesWithCategories.putIfAbsent(lastID, categories); //Place the results into the map if the lastID does not match the current movieID
                    lastID = movieID; //Set the current movieID to the lastID, so we can run through the loop and the if/else statements.
                    categories = new ArrayList<>(); //Make a new ArrayList so the old ones values don't come along
                    Category = rs.getString("Category");
                    CategoryID = rs.getInt("id");
                    Category c = new Category(CategoryID, Category);
                    categories.add(c); //Add the Category Object to the new List
                }
            }
            moviesWithCategories.putIfAbsent(movieID, categories); //Place the final results into the map.
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return moviesWithCategories;
    }

    /**
     * When a movie is selected in the Add Movie list, there are categories usually attached to the movie.
     * This method takes the data from the API and converts it to readable categories which are presented to the user in the GUI.
     *
     * @return List of all categories attached to a movie
     */
    public List<Category> getMovieCategories() {
        String movieCategories = myOMDBConnector.getMovieCategories(); //Get data from the API
        String[] c = movieCategories.split(", "); //Split the data into a String Array.
        ArrayList<Category> categories = new ArrayList<>();
        StringBuilder sqlBuilder = new StringBuilder("SELECT * FROM Categories WHERE");//SQL String which is looped with the String Array from above to make sure all relevant categories are received
        for (String s : c) {
            sqlBuilder.append(" Category = '").append(s).append("'").append(" OR");
        }
        String sql = //SQL String which is looped with the String Array from above to make sure all relevant categories are received
                sqlBuilder.toString();
        sql = sql.substring(0,sql.length()-3) + ";";

        try (Connection conn = databaseConnector.getConnection()) {
            executeStatements(categories, sql, conn);

        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
        return categories;
    }

    static void executeStatements(ArrayList<Category> categories, String sql, Connection conn) throws SQLException {
        Statement stmt = conn.createStatement();
        ResultSet rs = stmt.executeQuery(sql);
        while (rs.next()) {
            int id = rs.getInt("id");
            String catName = rs.getString("Category");
            //Create and add Categories to list
            Category category = new Category(id, catName);
            categories.add(category);
        }
    }

    /**
     * Adds one or more categories to a movie.
     *
     * @param mID        the movie
     * @param categories List of categories
     */
    @Override
    public void addCategoriesToMovie(int mID, List<Category> categories) {
        //SQL String which adds the categories attached to the movie, and loops through the list of categories to make sure they all are added
        String sql = "INSERT INTO CatMovie(MovieID, CategoryID) VALUES ";
        StringBuilder c = new StringBuilder();
        for (Category category : categories) {
            c.append("(").append(mID).append(",").append(category.getId()).append("), ");
        }
        c = new StringBuilder(c.substring(0, c.length() - 2)); //Trim the string
        c.append(";");
        //Try with resources on the databaseConnector
        try (Connection conn = databaseConnector.getConnection()) {
            PreparedStatement ps = conn.prepareStatement(sql + c);
            ps.executeUpdate(); //Execute Update
        } catch (SQLException ex) {
            ex.printStackTrace();
        }
    }

    /**
     * When the user chooses to add a movie, the list of categories needs to match ID's with categories in the DB.
     * This method creates an ArrayList of categories where the ID of the category is the index of the ArrayList
     * @param categories list of categories
     * @return Categories and their id's
     */
    @Override
    public List<Category> getUpdatedCategories(List<Category> categories) {
        ArrayList<Category> categories1 = new ArrayList<>();
        String[] c = categories.toString().split(", "); //A String Array is made with all the categories the user has chosen
        StringBuilder sql = new StringBuilder("SELECT * FROM Categories WHERE");
        for (String s : c) { //The loop goes through the Array and adds all categories to the SQL statement
            sql.append(" Category = '").append(s).append("'").append(" OR");
        }
        sql = new StringBuilder(sql.substring(0, sql.length() - 3) + ";"); //This trims the last "OR" away.
        sql = new StringBuilder(sql.toString().replaceAll("\\[", "")); //This trims any unwanted "[" away.
        sql = new StringBuilder(sql.toString().replaceAll("]", "")); //This trims any unwanted  "]" away.
        try (Connection conn = databaseConnector.getConnection()) {
            //Statement is a prepared SQL statement
            executeStatements(categories1, sql.toString(), conn);

        } catch (SQLException ex) {
            ex.printStackTrace();
        }
        return categories1;
    }
}